## 概念解释

1. **Scrum**
   - Scrum是一种敏捷软件开发框架，它强调团队协作、迭代式进展以及适应性规划。Scrum的核心组件包括Sprint（短周期迭代）、Sprint Backlog（迭代待办事项列表）、Product Backlog（产品待办事项列表）、Scrum Master（负责维护过程的成员）、Product Owner（代表客户或用户需求）以及开发团队。

2. **基于计划-文档开发方法（Plan-and-Document based Development）**
   - 这种方法强调在软件开发的早期阶段详细规划并记录所有的需求、设计、测试计划等。它通常与瀑布模型相关联，其中项目的每个阶段必须完成才能进入下一个阶段。

3. **DRY (Don’t Repeat Yourself) 无重复代码**
   - DRY原则提倡避免在代码中重复相同的逻辑或数据，通过抽象和模块化来实现。这有助于减少错误，提高代码的可读性和可维护性。

4. **MVC (Model-View-Controller)**
   - MVC是一种软件架构模式，用于分离应用程序的业务逻辑（模型）、用户界面（视图）和用户输入处理（控制器）。这种分离使得各个部分可以独立地修改和扩展，提高了系统的灵活性和可测试性。

5. **SMART 用户故事**
   - SMART是一个首字母缩写词，代表Specific（具体）、Measurable（可度量）、Achievable（可达成）、Relevant（相关）、Time-bound（时限性）。SMART用户故事是敏捷开发中编写用户需求的一种方式，确保它们清晰、可衡量且有明确的时间框架。

6. **TDD (Test-Driven Development)**
   - TDD是一种开发实践，开发者先编写测试用例，然后编写足以让这些测试通过的代码。这有助于确保代码的质量，并鼓励开发者考虑所有可能的边界情况。

7. **FIRST 测试原则**
   - FIRST是一个首字母缩写词，代表Fast（快速）、Isolated（隔离）、Repeatable（可重复）、Self-verifying（自验证）、Timely（及时）。这是为了确保测试的效率和可靠性而制定的一组指导原则。

8. **类内方法 SOFA 原则**
   - SOFA原则指的是Small（小）、Obvious（明显）、Focused（专注）、Atomic（原子性），用于指导类内部方法的设计，以确保它们简洁、目的明确且易于理解。

9. **类间关系的 SOLID 原则**
   - SOLID是一组面向对象设计原则的集合，包括Single Responsibility Principle（单一职责原则）、Open/Closed Principle（开闭原则）、Liskov Substitution Principle（里氏替换原则）、Interface Segregation Principle（接口隔离原则）、Dependency Inversion Principle（依赖倒置原则）。这些原则帮助创建灵活、可扩展和可维护的软件系统。

10. **持续集成**
    - 持续集成是一种软件开发实践，要求团队频繁地将代码合并到共享仓库中，通常是每天多次。每次合并后，自动构建和测试会立即运行，以便及早发现并修复问题。

11. **Free Software**
    - 自由软件是指用户有权自由运行、复制、分发、研究、更改和改进软件的软件。这个概念由自由软件基金会（FSF）提出，强调的是“自由”而非“免费”。

12. **Git 及分布式版本控制**
    - Git是一种分布式版本控制系统，允许团队成员在本地和远程存储库上独立工作，同时跟踪代码的变更历史。分布式特性意味着每个开发者的副本都包含完整的代码历史，这提供了高效率和灵活性。


## 选择题

1. D. blame: 归咎于
1. A
1. A
1. B. HEAD为当前版本
1. C
1. D. -A所有，-p逐个选择，-i交互界面
1. B
1. D
1. D
1. A
1. A
1. D
1. C
1. B
1. B. 用户故事通常在规划和开发阶段使用
1. C. A和D符合过程性场景描述
1. D
1. C
1. A. BDD (行为驱动开发) 的主要目标是通过持续交互来理解客户的需求。TDD（测试驱动开发）
1. C
1. A
1. B
1. B
1. A
1. C
1. BC
1. ABCD
1. C
1. D
1. D
1. AD
1. C
1. B
1. A
1. D
1. B
1. D. 不一定
1. D
1. B
1. C
1. A
1. B
1. D
1. B
1. D
1. D
1. AB
1. D
1. B
1. A. 概念：P&D和Agile
1. BD
1. B
1. C. OmniAuth 是 Strategy pattern （策略模式）的一个例子
1. E. Demeter 法则，也被称为 “最少知识原则”，它鼓励对象之间的低耦合
1. A
1. A
1. ABD
1. C
1. ABCE
1. E
1. C
1. D
1. A
1. A
1. A
1. D
1. CD
1. B
1. C
1. None
1. BC
1. D
1. D
1. B
1. C
1. C
1. ABCD
1. D
1. C
1. D. 等价类测试是一种黑盒测试技术
1. A
1. None
1. B
1. C
1. A
1. C. 开发错误指开发决策的问题
1. A. 异常指预期之外的情况
1. A
1. C
1. C
1. C. 题目打错了是*号
1. B
1. D
1. A
1. D
1. A
1. B
1. C
1. B
1. None
1. D
1. A
1. D
1. B. 行为——观察
1. A. 类图（Class Diagram）和对象图（Object Diagram）主要用于描述系统的结构，而不是行为。类图描述了系统中的类及其之间的关系，对象图则展示了系统运行时的对象及其关系
1. AB
1. C
1. B
1. BC
1. A
1. ABCDEF
1. ABCDE. 适配器模式（F）、修饰模式（G）、外观模式（H）和状态模式（I）不属于创建型模式。适配器模式和修饰模式属于结构型模式，而状态模式属于行为型模式
1. C
1. D
1. D
1. A
1. D
1. D
1. C
1. A
1. A
1. B
1. C
1. B
1. A
1. A
1. A
1. None
1. D
1. D
1. C
1. A
1. BD
1. AB
1. B
1. C
1. D
1. ABC
1. C
1. D
1. B
1. A
1. ABC
1. D
1. A
1. D
1. AD
1. C
1. A
1. D
1. A
1. D
1. D
1. A
1. A
1. B
1. C
1. B
1. B
1. D
1. A
1. A
1. A
1. D
1. D
1. C
1. B
1. A
1. C
1. A
1. D
1. C
1. D
1. C. +出大问题
1. B
1. A
1. B
1. B
1. C
1. D. rake db:create
1. BC
1. C
1. C
1. A
1. A. 在Ruby中，所有类都继承自Object类
1. D
1. B
1. B
1. D
1. D
1. C
1. B
1. C

## 判断题

1. T
1. T
1. F
1. T
1. F
1. T
1. F
1. F
1. T
1. F
1. F
1. F
1. T
1. T
1. F. “Mutation Testing”（变异测试）通过在源代码中人为地引入错误（称为“变异子”）来评估测试套件的有效性
1. T
1. F. C语言
1. F. 可重用的软件构件虽然经过严格测试，但在特定上下文中仍可能引入错误
1. T
1. T
1. T
1. F. 概要设计主要关注系统结构而非数据结构和算法
1. F
1. F. 雁群由大雁组成应属于关联关系，而不是聚合关系
1. F. 大雁由翅膀等组成属于组成关系（Composition），而不是聚合关系
1. T
1. F
1. T. 体现多态性
1. F
1. T
1. T
1. F. 面向方面编程 (AOP) 能够提炼横切关注点
1. T
1. T
1. F
1. T
1. F
1. T
1. F. 通过实例变量
1. F
1. F
1. T
1. T
1. T
1. T
1. T
1. T
1. T
1. F. Ruby 实际上有类型转换的概念
1. T
1. T
1. T
1. T
1. T
1. T
1. T
1. F. 设计类时不应使其具有多个目的，而是应该遵循单一职责原则
1. F
1. T
1. F. 责任边界设计不宜过于细化，应该恰到好处
1. F
1. T
1. T
1. T
1. F. 还有灰盒测试、回归测试等
1. T
1. F
1. F
1. T
1. T
1. T
1. F. 极限编程(XP)虽然强调快速反馈和频繁交付，但它也注重可持续的开发速度，避免开发团队过度劳累
1. T
1. F. 还有protected
1. T
1. T
1. F. 瀑布开发模型在每个阶段结束时写需求文档，而螺旋开发模型则在迭代过程中持续编写和更新需求文档
1. F
1. T
1. T
1. F. 还可能包括边界条件测试、错误处理测试等
1. F
1. F
1. F. 软件开发完成的标志是通过了所有预定的测试和验收标准
1. F
1. T
1. F
1. F. 不是具体依赖而是接口依赖
1. F
1. T
1. T
1. F
1. F
1. F. 先编写单元测试
1. F
1. T
1. T
1. T
1. F
1. T
1. F. user.send(:hello)
1. F
1. F. BDD必领域专家参与
1. F. 还需要进行风险评估、成本预算和技术可行性分析，才能着手实施
1. F
1. F
1. T
1. T
1. F
1. T
1. T
1. T
1. F. Rakefile文件主要用于定义各种任务，如数据库迁移、测试运行等，而不是保存日志文件或gem信息
1. T
1. T
1. F
1. F
1. T
1. F
1. F. 还包括文档、测试用例和其他辅助材料
1. F. 是解释型语言，但在执行前会先进行预编译，生成字节码，然后由虚拟机执行
1. F
1. F
1. T. Ruby是一种动态语言，你可以修改甚至重新定义内置的类
1. F
1. F. BDD使用场景描述和步骤定义来测试功能，而不是使用`assert`
1. F
1. T
1. T
1. T
1. F
1. T